(define prologue "
function concat() {
  throw new Error('Not implemented yet!');
}
")

(define (join args . joinr)
  (let ((joinr (get-from joinr 0 ", ")))
    (string:join args joinr)))

(define (collec val)
  (join (map codegen (val :value))))

(define (dict val)
  (join (map ($ (++ (codegen (car %)) ": " (codegen (cadr %)))) (val :value))))

(define (to-camel name)
  (let ((to-replace (regex:groups r/(-\w)/ name)))
    (if (null? to-replace)
      name
      (reduce (lambda (str pattern)
                (string:substitute str (car pattern)
                                (->string (char:upper-case (cadar pattern)))))
              name
              to-replace))))

(define (function name)
  (to-camel (regex:gsub r/:/ "." (->string name))))

(define (fun-name fun)
  (let ((mkfun (lambda (name) (make-hash :name name :type :fun)))
        (mkop  (lambda (name) (make-hash :name name :type :op)))
        (mkprop  (lambda (name) (make-hash :name name :type :prop))))
    (case fun
      ((+) (mkop "+"))
      ((*) (mkop "*"))
      ((/) (mkop "/"))
      ((-) (mkop "-"))
      ((>) (mkop ">"))
      ((>=) (mkop ">="))
      ((<=) (mkop "<="))
      ((<) (mkop "<"))
      ((/= <>) (mkop "!="))
      ((++) (mkfun "concat"))
      ((eqv?) (mkop "=="))
      ((eq? =) (mkop "==="))
      ((->string) (mkprop "toString"))
      ((write newline) (mkfun "console.log"))
      ((display) (mkfun "process.stdout.write"))
      ((error) (mkfun "console.error"))
      (else (mkfun (function fun))))))

(define (treat-app val)
  (let* ((fun (val :function))
         (args (map codegen (val :arguments)))
         (args-joined (join args)))
    (case (fun :type)
      ((:symbol)
        (let ((fun (fun-name (fun :value))))
          (case (fun :type)
            ((:fun)
              (++ (fun :name) "(" args-joined ")"))
            ((:op)
              (string:join args (++ " " (fun :name) " ")))
            ((:prop)
              (++ (car args) "." (fun :name) "(" (join (cdr args)) ")"))
            (else
              (error:from-string
                (++ "Got a bad form in function application: " fun))))))
      ((:lambda :define-fun)
        (++ "(" (codegen fun) ")(" args-joined ")"))
      (else (++ (codegen fun) "[" args-joined "]")))))

(define (codegen val)
  (case (val :type)
    ((:string :char) (++ "\"" (val :value) "\""))
    ((:atom) (++ "\"" (cdr (->string (val :value))) "\""))
    ((:list :vector) (++ "[" (collec val) "]"))
    ((:hash-map) (++ "{" (dict val) "}"))
    ((:byte-vector) (++ "new Uint8Array([" (collec val) "])"))
    ((:complex)
      (error:from-string "Complex numbers are not supported by this backend"))
    ((:rational)
      (->string (* 1.0 (val :value))))
    ((:application) (treat-app val))
    ((:define-val)
      (++ "var " (->string (val :name)) " = " (codegen (val :binding)) ";"))
    ((:define-fn)
      (++ "function " (codegen (val :name))
          "(" (join (map codegen (val :arguments))) ") {\n"
            "return " (codegen (val :body)) ";\n"
          "}"))
    ((:seq)
      (let ((ins (map codegen (val :arguments))))
        (++ "(function() {\n"
              (join (list:but-last ins) ";\n") "\n"
              "return " (list:last ins) ";\n})()")))
    ((:lambda)
      (++ "function(" (join (map codegen (val :arguments))) ") {"
          "return " (codegen (val :body)) ";"
          "}"))
    ((:symbol) (function (val :value)))
    ((:regex) (++ "/" (regex:pattern (val :value)) "/"))
    ((:nil) "null")
    ((:if) (++ "(function() {\n"
               "if (" (codegen (val :cond)) ") {\n"
               "return " (codegen (val :then)) ";\n"
               "} else {\n"
               "return " (codegen (val :else)) ";\n"
               "}})()"))
    (else (->string (val :value)))))

(define conf (make-hash :definitions  prologue
                        :macro-expand #t))

(zepto:implements-codegen :js codegen conf)
(write (zepto:run-compiler))
