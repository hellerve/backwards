(define prologue "function add() {
  return Array.from(arguments).reduce((a,b) => a + b, 0);
}
function mult() {
  return Array.from(arguments).reduce((a,b) => a * b, 1);
}
function div() {
  return [].slice.call(arguments, 1).reduce((a,b) => a / b, arguments[0]);
}
function sub() {
  return [].slice.call(arguments, 1).reduce((a,b) => a - b, arguments[0]);
}
function isnil(val) {
  return val === null;
}
function concat() {
  var concattr = function(a,b) {
    if (a.constructor === Array) {
      return a.concat(b);
    } else if (a.constructor === String) {
      return a + b;
    } else if (a.length !== undefined && b.length !== undefined) {
      var c = new a.constructor(a.length + b.length);
      c.set(a);
      c.set(b, a.length);

      return c;
    } else {
      var c = new a.constructor(a.length + 1);
      c.set(a);
      c.set(new a.constructor([b]), a.length);

      return c;
    }
  }
  var ary = Array.from(arguments);
  if (ary.length) {
    return ary.slice(1).reduce(concattr, ary[0]);
  }
}
function conj() {
  var concattr = function(a,b) {
    if (a.constructor === Array) {
      var c = Object.assign([], a);
      c.push(b);
      return c;
    } else if (a.constructor === String) {
      return a + b;
    } else {
      var c = new a.constructor(a.length + 1);
      c.set(a);
      c.set(b, a.length);

      return c;
    }
  }
  var ary = Array.from(arguments);
  if (ary.length) {
    return ary.slice(1).reduce(concattr, ary[0]);
  }
}
function guess(x, ...args) {
  if (x.constructor === Array || x.constructor === Object) {
    return args.reduce((a,b) => a[b], x);
  }
  return apply(x, args);
}
function isNull(x) {
  return x.length == 0;
}
function car(x) {
  return x[0];
}
function cdr(x) {
  return x.slice(1);
}
function apply(x) {
  return x.apply(null, [].slice.call(arguments, 1).reduce((a,b) => a.concat(b), []));
}
")

(define trans
  #{"+" "add"
    "*" "mult"
    "/" "div"
    "-" "sub"
    "%" "gen"
    "++" "conj"
    "+=" "concat"})

(define (join args . joinr)
  (let ((joinr (get-from joinr 0 ", ")))
    (string:join args joinr)))

(define (collec val)
  (join (map codegen (val :value))))

(define (dict val)
  (join (map ($ (++ (codegen (car %)) ": " (codegen (cadr %)))) (val :value))))

(define (to-camel name)
  (let ((to-replace (regex:groups r/(-\w)/ name)))
    (if (null? to-replace)
      name
      (reduce (lambda (str pattern)
                (string:substitute str (car pattern)
                                (->string (char:upper-case (cadar pattern)))))
              name
              to-replace))))

(define (no-interrobang str)
  (|> str
      ($ (if (string:ends-with str "!") (++ "unsafe" (but-last str)) str))
      ($ (if (string:ends-with str "?") (++ "is" (but-last str)) str))))

(define (function name)
  (let ((name (->string name)))
    (if (in? trans name)
      (trans name)
      (to-camel (no-interrobang (regex:gsub r/:/ "-" name))))))

(define (fun-name fun)
  (let ((mkfun   (lambda (name) (make-hash :name name :type :fun)))
        (mkunkwn (lambda (name) (make-hash :name name :type :unknown)))
        (mkop    (lambda (name) (make-hash :name name :type :op)))
        (mktrans (lambda (fun)  (make-hash :fun  fun  :type :trans)))
        (mkpropc (lambda (name) (make-hash :name name :type :propc)))
        (mkprop  (lambda (name) (make-hash :name name :type :prop))))
    (case fun
      ((+) (mkop "+"))
      ((*) (mkop "*"))
      ((/) (mkop "/"))
      ((-) (mkop "-"))
      ((>) (mkop ">"))
      ((>=) (mkop ">="))
      ((<=) (mkop "<="))
      ((<) (mkop "<"))
      ((/= <>) (mkop "!="))
      ((++) (mkfun "concat"))
      ((+=) (mkfun "conj"))
      ((list) (mktrans ($ (++ "[" (string:join % ", ") "]"))))
      ((eqv?) (mkop "=="))
      ((eq? =) (mkop "==="))
      ((set!) (mkop "="))
      ((null? list:null?) (mkfun "isNull"))
      ((head list:car) (mkfun "car"))
      ((tail list:cdr) (mkfun "cdr"))
      ((->string) (mkpropc "toString"))
      ((length) (mkprop "length"))
      ((write newline) (mkfun "console.log"))
      ((display) (mkfun "process.stdout.write"))
      ((error) (mkfun "console.error"))
      (else (mkunkwn (function fun))))))

(define (arg-list args)
  (if (list? args)
    (let ((gen (map codegen args)))
      (if (any? ($ (eq? (% :type) :rest)) args)
        (++ (list:sublist gen 0 (- (length gen) 2))
            (++ "..." (list:last gen)))
        gen))
    (list (++ "..." (function (args :value))))))

(define (treat-app val)
  (let* ((fun (val :function))
         (args (arg-list (val :arguments)))
         (args-joined (join args)))
    (case (fun :type)
      ((:symbol)
        (let ((fun (fun-name (fun :value))))
          (case (fun :type)
            ((:fun)
              (++ (fun :name) "(" args-joined ")"))
            ((:op)
              (string:join args (++ " " (fun :name) " ")))
            ((:prop)
              (++ (car args) "." (fun :name)))
            ((:propc)
              (++ (car args) "." (fun :name) "(" (join (cdr args)) ")"))
            ((:trans)
              ((fun :fun) args))
            ((:unknown)
              (++ "guess(" (fun :name) (if (truthy? (length args)) ", " "")
                   args-joined ")"))
            (else
              (error:from-string
                (++ "Got a bad form in function application: " fun))))))
      ((:lambda :define-fun)
        (++ "(" (codegen fun) ")(" args-joined ")"))
      (else (++ "guess(" (codegen fun) (if (truthy? (length args)) ", " "")
                args-joined ")")))))

(define (codegen val)
  (case (val :type)
    ((:string :char) (++ "\"" (val :value) "\""))
    ((:atom) (++ "\"" (cdr (->string (val :value))) "\""))
    ((:list :vector) (++ "[" (collec val) "]"))
    ((:hash-map) (++ "{" (dict val) "}"))
    ((:byte-vector) (++ "new Uint8Array([" (collec val) "])"))
    ((:complex)
      (error:from-string "Complex numbers are not supported by this backend"))
    ((:rational)
      (->string (* 1.0 (val :value))))
    ((:application) (treat-app val))
    ((:define-val)
      (++ "var " (function (->string (val :name))) " = "
          (codegen (val :binding)) ";"))
    ((:define-fn)
      (++ "function " (codegen (val :name))
          "(" (join (arg-list (val :arguments))) ") {\n"
            "return " (codegen (val :body)) ";\n"
          "}"))
    ((:seq)
      (let ((ins (map codegen (val :arguments))))
        (++ "(function() {\n"
              (join (list:but-last ins) ";\n") "\n"
              "return " (list:last ins) ";\n})()")))
    ((:lambda)
      (let ((args (arg-list (val :arguments))))
        (++ "function(" (join args) ") {"
            "return " (codegen (val :body)) ";"
            "}")))
    ((:symbol) (function (val :value)))
    ((:regex) (++ "/" (regex:pattern (val :value)) "/"))
    ((:nil) "null")
    ((:if) (++ "(function() {\n"
               "if (" (codegen (val :cond)) ") {\n"
               "return " (codegen (val :then)) ";\n"
               "} else {\n"
               "return " (codegen (val :else)) ";\n"
               "}})()"))
    (else (->string (val :value)))))

(define conf (make-hash :definitions  prologue
                        :macro-expand #t))

(zepto:implements-codegen :js codegen conf)
(define res (catch-vm-error '(zepto:run-compiler :js)))

(if (error? res)
  (write res))
